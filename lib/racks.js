// Generated by CoffeeScript 1.7.1
(function() {
  "use strict";
  var RacksJS;

  module.exports = RacksJS = (function() {
    function RacksJS(authObj, callback) {
      this.authObj = authObj;
      this.https_node = require('https');
      this.url = require('url');
      this.fs = require('fs');
      this.authToken = false;
      this.products = {};
      if (this.authObj == null) {
        this.authObj = {};
      }
      if (this.authObj.verbosity == null) {
        this.verbosity = 0;
      } else {
        this.verbosity = this.authObj.verbosity;
      }
      if (this.authObj.endpoint == null) {
        this.authObj.endpoint = 'https://identity.api.rackspacecloud.com/v2.0';
      }
      if (this.authObj.test == null) {
        this.test = false;
      } else {
        this.test = this.authObj.test;
      }
      this.buildProducts();
      if ((this.authObj.username != null) && (this.authObj.apiKey != null) && (callback != null)) {
        this.authenticate(this.authObj, callback);
      }
      this.network = 'public';
    }

    RacksJS.prototype.log = function(message, verbose) {
      if (this.verbosity === 1) {
        return console.log(message);
      } else if (this.verbosity > 1) {
        if (message == null) {
          message = '[DEBUG]';
        }
        return console.log(message, verbose);
      }
    };

    RacksJS.prototype.https = function(opts, callback) {
      var plaintext, request;
      if (opts.headers == null) {
        opts.headers = {};
      }
      plaintext = opts.plaintext;
      delete opts.plaintext;
      if (this.authToken) {
        opts.headers['X-Auth-Token'] = this.authToken;
      }
      opts.headers['Content-Type'] = 'application/json';
      if (opts.data != null) {
        if (typeof opts.data === 'object') {
          opts.data = JSON.stringify(opts.data);
        }
        opts.headers['Content-Length'] = opts.data.length;
      }
      opts.url = this.url.parse(opts.url);
      opts.host = opts.url.host;
      opts.path = opts.url.path;
      delete opts.url;
      if (this.verbosity > 3) {
        this.log('HTTP Request: ', opts);
      }
      if (this.test) {
        return this.mockApi(opts, callback);
      } else {
        request = this.https_node.request(opts, (function(_this) {
          return function(response) {
            var rawReply;
            rawReply = '';
            response.setEncoding('utf8');
            response.on('data', function(responseChunk) {
              return rawReply = rawReply + responseChunk;
            });
            response.on('end', function() {
              var error, reply;
              if (plaintext) {
                if (rawReply.length === 0) {
                  reply = [];
                } else {
                  reply = rawReply.substr(0, rawReply.length - 1).split("\n");
                }
              } else {
                try {
                  reply = JSON.parse(rawReply);
                } catch (_error) {
                  error = _error;
                  reply = rawReply;
                }
              }
              if (_this.verbosity > 4) {
                _this.log('HTTP Reply:', reply);
              }
              return callback(reply);
            });
            return response.on('error', function(error) {
              return _this.log(error, opts);
            });
          };
        })(this));
        if (opts.data != null) {
          request.write(opts.data);
        }
        return request.end();
      }
    };

    RacksJS.prototype.get = function(url, callback) {
      return this.https({
        method: 'GET',
        url: url
      }, callback);
    };

    RacksJS.prototype.post = function(url, data, callback) {
      return this.https({
        method: 'POST',
        url: url,
        data: data
      }, callback);
    };

    RacksJS.prototype["delete"] = function(url, callback) {
      return this.https({
        method: 'DELETE',
        url: url
      }, callback);
    };

    RacksJS.prototype.put = function(url, callback) {
      return this.https({
        method: 'PUT',
        url: url
      }, callback);
    };

    RacksJS.prototype.authenticate = function(authObj, callback) {
      if ((authObj.username == null) || (authObj.apiKey == null)) {
        return callback({
          error: 'No username or apiKey provided to .authenticate()'
        });
      }
      return this.post(authObj.endpoint + '/tokens', {
        'auth': {
          'RAX-KSKEY:apiKeyCredentials': {
            'username': authObj.username,
            'apiKey': authObj.apiKey
          }
        }
      }, (function(_this) {
        return function(response) {
          if (response.access != null) {
            _this.authToken = response.access.token.id;
            _this.access = response.access;
            _this.error = false;
            _this.serviceCatalog = response.access.serviceCatalog;
            _this.buildCatalog(_this.serviceCatalog);
          } else {
            _this.log('Auth failed', response);
            _this.error = 'Auth failed';
          }
          return callback(_this);
        };
      })(this));
    };

    RacksJS.prototype.buildModel = function(template, raw) {
      var model;
      if (template.model != null) {
        model = template.model(raw);
      } else {
        return raw;
      }
      model._racksmeta = {
        resource: template._racksmeta.name,
        product: template._racksmeta.product,
        target: (function(_this) {
          return function() {
            var idOrName, target;
            target = template._racksmeta.target();
            idOrName = '';
            if (target.substr(-1) === '/') {
              target = target.substr(0, target.length - 1);
            }
            if (model.id != null) {
              idOrName = model.id;
            } else if (model.name != null) {
              idOrName = model.name;
            }
            return target + '/' + idOrName;
          };
        })(this)
      };
      return model;
    };

    RacksJS.prototype.resourceRequest = function(resource, callback) {
      return this.https({
        url: resource._racksmeta.target(),
        plaintext: resource._racksmeta.plaintext,
        method: 'GET'
      }, (function(_this) {
        return function(reply) {
          var metaName, response;
          metaName = resource._racksmeta.name;
          if (resource._racksmeta.replyString != null) {
            metaName = resource._racksmeta.replyString;
          }
          console.log(reply);
          if (reply[metaName] != null) {
            if (resource.model) {
              if (reply[metaName].push != null) {
                response = [];
                reply[metaName].forEach(function(raw) {
                  return response.push(_this.buildModel(resource, raw));
                });
                return callback(response);
              } else {
                return callback(_this.buildModel(resource, reply[metaName]));
              }
            } else {
              return callback(reply[metaName]);
            }
          } else if (resource._racksmeta.plaintext != null) {
            response = [];
            reply.forEach(function(raw) {
              return response.push(_this.buildModel(resource, raw));
            });
            return callback(response);
          } else {
            _this.log(void 0, 'product wrapping failure - contact the developers of racksjs', resource.meta);
            return callback(reply);
          }
        };
      })(this));
    };

    RacksJS.prototype.subResource = function(resource, id, subResource) {
      return this.buildResource(resource._racksmeta.product, resource._racksmeta.name + '/' + subResource, {
        _racksmeta: {
          resourceString: subResource,
          name: subResource,
          target: (function(_this) {
            return function() {
              return resource._racksmeta.target() + '/' + id + '/' + subResource;
            };
          })(this)
        }
      });
    };

    RacksJS.prototype.buildResource = function(productName, resourceName, subResource) {
      var rack, resource;
      if (subResource != null) {
        resource = subResource;
      } else {
        resource = this[productName][resourceName];
      }
      if (resource._racksmeta == null) {
        resource._racksmeta = {};
      }
      if (resource._racksmeta.name == null) {
        resource._racksmeta.name = resourceName;
      }
      resource._racksmeta.product = productName;
      rack = this;
      if (resource._racksmeta.target == null) {
        resource._racksmeta.target = function() {
          var resourcePath;
          if (resource._racksmeta.resourceString != null) {
            resourcePath = resource._racksmeta.resourceString;
          } else {
            resourcePath = this.name;
          }
          return rack[productName]._racksmeta.target() + resourcePath;
        };
      }
      if (!resource._racksmeta.noResource) {
        resource.all = (function(_this) {
          return function(callback) {
            return _this.resourceRequest(resource, callback);
          };
        })(this);
        resource.assume = (function(_this) {
          return function(obj, callback) {
            if (typeof obj === 'string') {
              obj = {
                id: obj
              };
            }
            if ((obj.id == null) && (obj.name == null)) {
              return _this.log('[INFO] .assume() relies on .target() which in turn requires the object argument to have a .id or .name - please define one or the other - alternatively you can pass a string, in which case skinny will assume youre providing an id');
            }
            return _this.buildModel(resource, obj);
          };
        })(this);
      }
      return resource;
    };

    RacksJS.prototype.buildCatalog = function(serviceCatalog) {
      var rack;
      rack = this;
      return serviceCatalog.forEach((function(_this) {
        return function(product) {
          var resource, resourceName, _ref, _results;
          if (product.name == null) {
            return false;
          }
          if (_this[product.name] != null) {
            _this[product.name]._racksmeta = {
              endpoints: product.endpoints,
              target: function() {
                var dc, target;
                target = false;
                if (rack.datacenter != null) {
                  dc = rack.datacenter;
                } else {
                  dc = rack.access.user['RAX-AUTH:defaultRegion'];
                }
                if (this.endpoints.length > 1) {
                  this.endpoints.forEach((function(_this) {
                    return function(endpoint) {
                      if (endpoint.region === dc) {
                        return target = endpoint[rack.network.toLowerCase() + 'URL'];
                      }
                    };
                  })(this));
                } else {
                  target = this.endpoints[0];
                }
                if (typeof target === 'object') {
                  target = target[rack.network.toLowerCase() + 'URL'];
                }
                if (target.substr(-1) !== '/') {
                  target = target + '/';
                }
                return target;
              }
            };
            _this.products[product.name] = {};
            _ref = _this[product.name];
            _results = [];
            for (resourceName in _ref) {
              resource = _ref[resourceName];
              if (_this[product.name].hasOwnProperty(resourceName)) {
                if (resourceName !== '_racksmeta') {
                  _this[product.name][resourceName] = _this.buildResource(product.name, resourceName);
                  _results.push(_this.products[product.name][resourceName] = _this[product.name][resourceName]);
                } else {
                  _results.push(void 0);
                }
              } else {
                _results.push(void 0);
              }
            }
            return _results;
          } else {
            return _this.log('no product named "' + product.name + '" found in racksjs - please contact the maintainers');
          }
        };
      })(this));
    };

    RacksJS.prototype.mockApi = function(opts, callback) {
      var fakeEndpoints;
      if ((opts.data != null) && opts.data.match(/apiKeyCredentials/)) {
        fakeEndpoints = ['http://some-fake-testing-url.com', 0, 1, 2];
        return callback({
          access: {
            token: {
              id: 'some-fake-testing-id'
            },
            serviceCatalog: [
              {
                name: 'cloudServersOpenStack',
                endpoints: fakeEndpoints
              }
            ]
          }
        });
      } else {
        return callback([
          {
            id: 1
          }, {
            id: 2
          }
        ]);
      }
    };

    RacksJS.prototype.buildProducts = function() {
      var rack;
      rack = this;
      this.cloudServersOpenStack = {
        networks: {
          _racksmeta: {
            resourceString: 'os-networksv2'
          },
          model: function(raw) {
            raw.show = function(callback) {
              var _ref;
              if ((_ref = raw.label) === 'public' || _ref === 'private') {
                return callback({
                  network: {
                    id: raw.id,
                    label: raw.label,
                    cidr: void 0
                  }
                });
              } else {
                return rack.get(this._racksmeta.target(), callback);
              }
            };
            return raw;
          }
        },
        flavors: {
          model: function(raw) {
            raw.details = function(callback) {
              return rack.get(this._racksmeta.target(), callback);
            };
            return raw;
          }
        },
        images: {
          model: function(raw) {
            raw.details = function(callback) {
              return rack.get(this._racksmeta.target(), callback);
            };
            return raw;
          }
        },
        servers: {
          _racksmeta: {
            requiredFields: {
              name: 'string',
              imageRef: 'string',
              flavorRef: 'string'
            }
          },
          model: function(raw) {
            raw.details = function(callback) {
              return rack.get(this._racksmeta.target(), function(reply) {
                return callback(reply.server);
              });
            };
            raw.addresses = function(callback) {
              return rack.get(this._racksmeta.target() + '/ips', callback);
            };
            raw["delete"] = function(callback) {
              return rack["delete"](this._racksmeta.target(), callback);
            };
            raw.action = function(obj, callback) {
              return rack.post(this._racksmeta.target() + '/action', obj, callback);
            };
            raw.reboot = function(type, callback) {
              var cb;
              if (typeof type === 'function') {
                cb = type;
                type = 'SOFT';
              }
              return raw.action({
                reboot: {
                  type: type
                }
              }, callback);
            };
            raw.resize = function(options, callback) {
              if (typeof options === 'string') {
                options = {
                  "flavorRef": options
                };
              }
              return raw.action({
                resize: options
              }, callback);
            };
            return raw;
          }
        }
      };
      this.cloudServers = {
        servers: {
          model: function(raw) {
            return raw;
          }
        },
        images: {
          model: function(raw) {
            return raw;
          }
        },
        flavors: {
          model: function(raw) {
            return raw;
          }
        }
      };
      this.cloudLoadBalancers = {
        algorithms: {
          model: function(raw) {
            return raw;
          }
        },
        alloweddomains: {
          model: function(raw) {
            return raw;
          }
        },
        protocols: {
          model: function(raw) {
            return raw;
          }
        },
        loadBalancers: {
          model: function(raw) {
            return raw;
          }
        }
      };
      this.cloudFilesCDN = {};
      this.cloudFiles = {
        containers: {
          model: function(containerName) {
            var catalog;
            catalog = {
              name: containerName,
              _racksmeta: {
                name: containerName
              }
            };
            return catalog;
          }
        }
      };
      this.autoscale = {
        groups: {
          model: function(raw) {
            return raw;
          }
        }
      };
      this.cloudBlockStorage = {
        volumes: {
          model: function(raw) {
            return raw;
          }
        },
        types: {
          model: function(raw) {
            return raw;
          }
        }
      };
      this.cloudDatabases = {
        instances: {
          model: function(raw) {
            return raw;
          }
        }
      };
      this.cloudOrchestration = {};
      this.cloudQueues = {
        queues: {
          model: function(raw) {
            return raw;
          }
        }
      };
      this.cloudBackup = {
        configurations: {
          model: function(raw) {
            return raw;
          }
        },
        agents: {
          model: function(raw) {
            return raw;
          }
        }
      };
      this.cloudDNS = {
        limits: {
          model: function(raw) {
            return raw;
          }
        },
        domains: {
          model: function(raw) {
            return raw;
          }
        },
        rdns: {
          model: function(raw) {
            return raw;
          }
        }
      };
      this.cloudImages = {};
      this.cloudMonitoring = {
        entities: {
          model: function(raw) {
            return raw;
          }
        },
        limits: {
          model: function(raw) {
            return raw;
          }
        },
        audits: {
          model: function(raw) {
            return raw;
          }
        },
        checkTypes: {
          model: function(raw) {
            return raw;
          }
        },
        monitoringZones: {
          model: function(raw) {
            return raw;
          }
        },
        notifications: {
          model: function(raw) {
            return raw;
          }
        },
        agents: {
          model: function(raw) {
            return raw;
          }
        },
        overview: function(callback) {
          return rack.get(this._racksmeta.target() + 'views/overview', callback);
        }
      };
      this.servers = this.cloudServersOpenStack.servers;
      this.networks = this.cloudServersOpenStack.networks;
      this.ngservers = this.cloudServersOpenStack.servers;
      this.nextgen = this.cloudServersOpenStack;
      this.fgservers = this.cloudServers.servers;
      this.firstgen = this.cloudServers;
      return this.clbs = this.cloudLoadBalancers.loadBalancers;
    };

    return RacksJS;

  })();

}).call(this);
